"""
Fetch igdb game IDs for each steam entry found in a csv generated by `steamExportLibrary.py`.
Requirements:
- .env file with `twitch_client_id` and `twitch_client_secret`
- `steamExportLibrary.py` must have been run first to generate the `steam-export.csv` file.
Outputs a new CSV file with the IGDB IDs added as an additional column.
"""

import os
import csv
import time
import requests
from typing import Optional, Dict, List
from pathlib import Path
from dotenv import load_dotenv
import time

from clilog import log, VERBOSITY_INFO, VERBOSITY_DEBUG, VERBOSITY_TRACE, VERBOSITY_ERROR, VERBOSITY_WARNING, VERBOSITY

# ───────────────────────────────────────────
# ENV / CONFIG
# ───────────────────────────────────────────
_next_allowed_time = 0  # module-level or global variable to track timing
IGDB_BASE = "https://api.igdb.com/v4"

env_path = Path(__file__).parent.parent / ".env"
load_dotenv(dotenv_path=env_path)
twitch_client_id: str = os.getenv("twitch_client_id")
twitch_client_secret: str = os.getenv("twitch_client_secret")
igbd_rate_frequency_ms: int = int(os.getenv("igbd_rate_frequency_ms", "250"))

log(f"[igdb_lookup] twitch_client_id = {twitch_client_id}", VERBOSITY_TRACE)
log(f"[igdb_lookup] igbd_rate_frequency_ms = {igbd_rate_frequency_ms}", VERBOSITY_TRACE)

# ───────────────────────────────────────────
# AUTH & API HELPERS
# ───────────────────────────────────────────
def get_bearer_token(client_id: str, client_secret: str) -> str:
    resp = requests.post(
        "https://id.twitch.tv/oauth2/token",
        data={
            "client_id": client_id,
            "client_secret": client_secret,
            "grant_type": "client_credentials",
        },
        timeout=10,
    )
    if resp.status_code != 200:
        log(f"igdbSteamLookup.py.get_bearer_token: Auth failed: {resp.status_code} - {resp.text}", VERBOSITY_ERROR)
        raise RuntimeError(f"Auth failed: {resp.status_code} - {resp.text}")
    return resp.json()["access_token"]

def igdb_headers(token: str, client_id: str) -> Dict[str, str]:
    return {
        "Client-ID": client_id,
        "Authorization": f"Bearer {token}",
    }

def steam_or_title_to_igdb_id(appid: str | int,
                              title: str,
                              headers: Dict[str, str]) -> Optional[int]:
    """
    Attempts to get IGDB game ID from a Steam App ID.
    Falls back to searching by game title if no result is found via external_games.
    """
    # Attempt lookup via steam appid
    query_id = f'fields game; where category = 1 & uid = "{appid}";'
    log(f"igdbSteamLookup.py.steam_or_title_to_igdb_id: Querying IGDB external_games for AppID {appid}", VERBOSITY_TRACE)
    resp = igdb_post("external_games", query_id, headers)
    resp.raise_for_status()
    data = resp.json()

    if data:
        game_id = data[0]["game"]
        log(f"igdbSteamLookup.py.steam_or_title_to_igdb_id: Found IGDB ID {game_id} for AppID {appid} via external_games", VERBOSITY_DEBUG)
        return game_id

    log(f"igdbSteamLookup.py.steam_or_title_to_igdb_id: No IGDB ID found for AppID {appid}, falling back to title search: '{title}'", VERBOSITY_WARNING)

    # Attempt lookup via steam name
    query_name = (
        f'search "{title}";'
        f'fields id, name;'
        f'where category = 0; limit 1;'
    )
    log(f"igdbSteamLookup.py.steam_or_title_to_igdb_id: Querying IGDB games for title '{title}'", VERBOSITY_TRACE)
    resp = igdb_post("games", query_name, headers)
    resp.raise_for_status()
    data = resp.json()

    if data:
        game_id = data[0]["id"]
        log(f"Found IGDB ID {game_id} for title '{title}'", VERBOSITY_INFO)
        return game_id

    log(f"igdbSteamLookup.py.steam_or_title_to_igdb_id: No IGDB ID found for title '{title}'", VERBOSITY_WARNING)
    return None

def igdb_post(endpoint: str, query: str, headers: Dict[str, str]) -> requests.Response:
    global _next_allowed_time
    now = time.time()

    # Wait only if we must to respect rate limiting
    if now < _next_allowed_time:
        wait_seconds = _next_allowed_time - now
        log(f"igdbSteamLookup.py.igdb_post: Waiting {wait_seconds:.3f}s to respect rate limit", VERBOSITY_TRACE)
        time.sleep(wait_seconds)

    if VERBOSITY == VERBOSITY_TRACE:
        log(f"igdbSteamLookup.py.igdb_post: POST {IGDB_BASE}/{endpoint}", VERBOSITY_TRACE)
        log(f"igdbSteamLookup.py.igdb_post:Headers: {headers}", VERBOSITY_TRACE)
        log(f"igdbSteamLookup.py.igdb_post:Data: {query}", VERBOSITY_TRACE)

    resp = requests.post(f"{IGDB_BASE}/{endpoint}", headers=headers, data=query, timeout=10)

    # After request, set next allowed time
    _next_allowed_time = time.time() + igbd_rate_frequency_ms / 1000

    if resp.status_code == 429:
        log(f"igdbSteamLookup.py.igdb_post: Rate limited on endpoint '{endpoint}', retrying after 10s", VERBOSITY_WARNING)
        time.sleep(10)
        resp = requests.post(f"{IGDB_BASE}/{endpoint}", headers=headers, data=query, timeout=10)
        _next_allowed_time = time.time() + igbd_rate_frequency_ms / 1000

    return resp

# ───────────────────────────────────────────
# MAIN BATCH PROCESSOR
# ───────────────────────────────────────────
#TODO: OLD def process_and_export_steam_rows(input_rows: List[Dict[str, str]]) -> List[Dict[str, str]]:
def process_and_export_steam_rows(input_rows: List[Dict[str, str]]):
    """
    Enrich each row from a Steam export with its IGDB game ID.
    Writes the result to ../output/steamIgdbLookup.csv and returns the new rows.
    """
    if not twitch_client_id and not twitch_client_secret:
        log("igdbSteamLookup.py.process_and_export_steam_rows: Both twitch_client_id and twitch_client_secret must be provided in .env", VERBOSITY_ERROR)
        return None
    token = get_bearer_token(twitch_client_id, twitch_client_secret)
    headers = igdb_headers(token, twitch_client_id)

    total = len(input_rows)

    log(f"Looking up {total} steam ID's", VERBOSITY_INFO)

    enriched: List[Dict[str, str]] = []
    for idx, row in enumerate(input_rows, start=1):
        appid = row.get("appid")
        title = row.get("name", "").strip()

        log(f"[{idx}/{total}] Looking up IGDB ID for Steam AppID {appid} / Title '{title}'", VERBOSITY_INFO)
        igdb_id = steam_or_title_to_igdb_id(appid, title, headers)

        if igdb_id is None:
            log(f"igdbSteamLookup.py.process_and_export_steam_rows: No IGDB ID found for AppID {appid} / Title '{title}'", VERBOSITY_WARNING)
            continue

        log(f"igdbSteamLookup.py.process_and_export_steam_rows: Found IGDB ID {igdb_id} for AppID {appid} / Title '{title}'", VERBOSITY_DEBUG)
        row["igdb_id"] = str(igdb_id)
        enriched.append(row)

    # Output
    output_dir = Path(__file__).parent.parent / "output"
    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = output_dir / "steamIgdbLookup.csv"

    with output_path.open("w", newline="", encoding="utf-8") as fh:
        fieldnames = list(enriched[0].keys())
        writer = csv.DictWriter(fh, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(enriched)

    log(f"igdbSteamLookup.py.process_and_export_steam_rows: Wrote {len(enriched)} rows to {output_path}", VERBOSITY_INFO)
    return str(output_path.resolve())

# ───────────────────────────────────────────
# OPTIONAL STAND‑ALONE EXECUTION
# ───────────────────────────────────────────
if __name__ == "__main__":
    """
    Runs this script as a standalone utility using the default export file from `steamExportLibrary.py`.
    Expects the file to be in ../output/steam-export.csv.
    """
    # Quick demo: load the steam-export CSV and enrich it
    demo_input = Path(__file__).parent.parent / "output" / "steam-export.csv"
    if not demo_input.exists():
        raise FileNotFoundError("Run steam_library.py first to produce steam-export.csv")

    with demo_input.open(newline="", encoding="utf-8") as fh:
        reader = csv.DictReader(fh)
        rows = list(reader)

    process_and_export_steam_rows(rows)
